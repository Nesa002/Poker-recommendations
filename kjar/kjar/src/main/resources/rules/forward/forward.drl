package rules.backward

import com.ftn.sbnz.model.models.Round;
import com.ftn.sbnz.service.services.HandService;

global HandService handService;
global Double min_bigger_raise;
global Integer min_bigger_raise_blinds;
global Integer bad_position_treshold;
global Double min_strong_hand;
global Double min_medium_hand;
global Double tableAggressiveness;

// --- HELPER FACTS ---
declare IsBelowMediumHand round: Round end
declare IsNotStrongHand round: Round end
declare IsBigRaise round: Round end
declare IsInBadPosition round: Round end
declare HasWeakEconomy round: Round end
declare IsTableAggressionLow end

// --- DERIVATION RULES ---
rule "Derive Hand Strength - Below Medium"
when
    $r: Round(handService.getWinPercentage(getHand()) < min_medium_hand)
then
    insert(new IsBelowMediumHand($r));
end

rule "Derive Hand Strength - Not Strong"
when
    $r: Round(handService.getWinPercentage(getHand()) < min_strong_hand)
then
    insert(new IsNotStrongHand($r));
end

rule "Derive Big Raise"
when
    $r: Round(currentRaise >= min_bigger_raise_blinds * bigBlindSize || currentRaise > min_bigger_raise * pot)
then
    insert(new IsBigRaise($r));
end

rule "Derive Bad Position"
when
    $r: Round(playerPosition <= bad_position_treshold)
then
    insert(new IsInBadPosition($r));
end

rule "Derive Weak Economy"
when
    $r: Round(strongEconomy == false)
then
    insert(new HasWeakEconomy($r));
end

rule "Derive Low Table Aggression"
no-loop
when
    not IsTableAggressionLow()
    eval(tableAggressiveness < 0)
then
    insert(new IsTableAggressionLow());
end

// --- BACKWARD-CHAINING QUERY ---
query shouldFold(Round $r)
    IsBelowMediumHand(round == $r) or
    (IsBigRaise(round == $r) and IsNotStrongHand(round == $r)) or
    (IsInBadPosition(round == $r) and IsNotStrongHand(round == $r)) or
    (IsBelowMediumHand(round == $r) and HasWeakEconomy(round == $r))
end
